export interface PostgresSchema {
  columns: {
    tableCatalog: string;
    tableSchema: string;
    tableName: string;
    columnName: string;
    ordinalPosition: number;
    columnDefault: string;
    isNullable: string;
    dataType: string;
    characterMaximumLength: number;
    characterOctetLength: number;
    numericPrecision: number;
    numericPrecisionRadix: number;
    numericScale: number;
    datetimePrecision: number;
    intervalType: string;
    intervalPrecision: number;
    characterSetCatalog: string;
    characterSetSchema: string;
    characterSetName: string;
    collationCatalog: string;
    collationSchema: string;
    collationName: string;
    domainCatalog: string;
    domainSchema: string;
    domainName: string;
    udtCatalog: string;
    udtSchema: string;
    udtName: string;
    scopeCatalog: string;
    scopeSchema: string;
    scopeName: string;
    maximumCardinality: number;
    dtdIdentifier: string;
    isSelfReferencing: string;
    isIdentity: string;
    identityGeneration: string;
    identityStart: string;
    identityIncrement: string;
    identityMaximum: string;
    identityMinimum: string;
    identityCycle: string;
    isGenerated: string;
    generationExpression: string;
    isUpdatable: string;
  };
  constraintColumnUsage: {
    tableCatalog: string;
    tableSchema: string;
    tableName: string;
    columnName: string;
    constraintCatalog: string;
    constraintSchema: string;
    constraintName: string;
  };
  keyColumnUsage: {
    constraintCatalog: string;
    constraintSchema: string;
    constraintName: string;
    tableCatalog: string;
    tableSchema: string;
    tableName: string;
    columnName: string;
    ordinalPosition: number;
    positionInUniqueConstraint: number;
  };
  tableConstraints: {
    constraintCatalog: string;
    constraintSchema: string;
    constraintName: string;
    tableCatalog: string;
    tableSchema: string;
    tableName: string;
    constraintType: string;
    isDeferrable: string;
    initiallyDeferred: string;
    enforced: string;
  };
  tables: {
    tableCatalog: string;
    tableSchema: string;
    tableName: string;
    tableType: string;
    selfReferencingColumnName: string;
    referenceGeneration: string;
    userDefinedTypeCatalog: string;
    userDefinedTypeSchema: string;
    userDefinedTypeName: string;
    isInsertableInto: string;
    isTyped: string;
    commitAction: string;
  };
  pgConstraint: {
    oid: number;
    conname: string;
    connamespace: number;
    contype: string;
    condeferrable: boolean;
    condeferred: boolean;
    convalidated: boolean;
    conrelid: number;
    contypid: number;
    conindid: number;
    conparentid: number;
    confrelid: number;
    confupdtype: string;
    confdeltype: string;
    confmatchtype: string;
    conislocal: boolean;
    coninhcount: number;
    connoinherit: boolean;
    conkey: number[];
    confkey: number[];
    conpfeqop: number[];
    conppeqop: number[];
    conffeqop: number[];
    conexclop: number[];
    conbin: string;
  };
  pgEnum: {
    oid: number;
    enumtypid: number;
    enumsortorder: number;
    enumlabel: string;
  };
  pgNamespace: {
    oid: number;
    nspname: string;
    nspowner: number;
    nspacl: string[];
  };
  pgType: {
    oid: number;
    typname: string;
    typnamespace: number;
    typowner: number;
    typlen: number;
    typbyval: boolean;
    typtype: string;
    typcategory: string;
    typispreferred: boolean;
    typisdefined: boolean;
    typdelim: string;
    typrelid: number;
    typelem: number;
    typarray: number;
    typinput: string;
    typoutput: string;
    typreceive: string;
    typsend: string;
    typmodin: string;
    typmodout: string;
    typanalyze: string;
    typalign: string;
    typstorage: string;
    typnotnull: boolean;
    typbasetype: number;
    typtypmod: number;
    typndims: number;
    typcollation: number;
    typdefaultbin: string;
    typdefault: string;
    typacl: string[];
  };
}
